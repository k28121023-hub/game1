<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- é—œéµï¼šviewport-fit=cover è®“å…§å®¹å»¶ä¼¸åˆ°å…¨è¢å¹•ï¼Œé˜²æ­¢ç™½é‚Š -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>é¤é£²å–®å­—å¤§å°„æ“Š (Mobile Fixed)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* å…¨åŸŸè¨­å®šï¼šé–å®šç•«é¢ï¼Œé˜²æ­¢æ•´é«”ç¶²é æ»‘å‹• */
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #111827;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            /* ç¦ç”¨é¸å–èˆ‡é•·æŒ‰é¸å–® */
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        /* éŠæˆ²ä¸»å®¹å™¨ */
        .game-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            /* ä½¿ç”¨ dvh ç¢ºä¿åœ¨æ‰‹æ©Ÿç€è¦½å™¨ä¸Šé«˜åº¦æ­£ç¢º */
            height: 100dvh; 
        }

        .game-canvas {
            background: linear-gradient(to bottom, #1a202c, #2d3748);
            box-shadow: inset 0 0 20px #000;
            touch-action: none; /* ç¦æ­¢ç•«å¸ƒä¸Šçš„é è¨­è§¸æ§è¡Œç‚º */
        }

        /* å„ªåŒ–æ²è»¸æ¨£å¼ */
        .custom-scroll::-webkit-scrollbar {
            width: 4px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 4px;
        }

        /* æŒ‰éˆ•æŒ‰å£“æ•ˆæœ */
        .btn-press {
            transition: transform 0.05s, background-color 0.1s;
            touch-action: manipulation;
        }
        .btn-press:active {
            transform: scale(0.96);
        }
    </style>
</head>
<body>

    <div class="game-wrapper">
        <!-- 1. é ‚éƒ¨è³‡è¨Šæ¬„ (å›ºå®šé«˜åº¦) -->
        <div class="flex justify-between items-center px-3 py-2 bg-gray-800 border-b border-gray-700 h-14 shrink-0 z-20 shadow-md">
            <div class="flex items-center gap-2">
                <span class="text-2xl">ğŸ›¡ï¸</span>
                <h1 class="text-base font-bold text-yellow-400 leading-tight">é¤é£²<br>è¡›å£«</h1>
            </div>
            <div class="flex gap-4">
                <div class="text-center">
                    <span class="block text-[10px] text-gray-400 uppercase">é€²åº¦</span>
                    <div id="progressDisplay" class="text-lg font-mono font-bold text-blue-400 leading-none">0/12</div>
                </div>
                <div class="text-center">
                    <span class="block text-[10px] text-gray-400 uppercase">åˆ†æ•¸</span>
                    <div id="scoreDisplay" class="text-lg font-mono font-bold text-green-400 leading-none">0</div>
                </div>
                <div class="text-center">
                    <span class="block text-[10px] text-gray-400 uppercase">ç”Ÿå‘½</span>
                    <div id="livesDisplay" class="text-lg font-mono font-bold text-red-400 leading-none tracking-tighter">â¤â¤â¤</div>
                </div>
            </div>
        </div>

        <!-- 2. éŠæˆ²ç•«å¸ƒ (è‡ªå‹•å¡«æ»¿å‰©é¤˜ç©ºé–“ flex-grow) -->
        <div class="flex-grow relative w-full overflow-hidden bg-gray-900" id="canvasContainer">
            <canvas id="gameCanvas" class="game-canvas block w-full h-full"></canvas>
            
            <!-- é–‹å§‹ç•«é¢ -->
            <div id="startScreen" class="absolute inset-0 bg-black/85 flex flex-col justify-center items-center z-30 p-6 backdrop-blur-sm">
                <h2 class="text-3xl font-bold mb-6 text-white text-center">é¤é£²å–®å­—å¤§å°„æ“Š</h2>
                <div class="bg-gray-800/80 p-5 rounded-xl border border-gray-600 mb-8 max-w-sm w-full">
                    <ul class="space-y-4 text-gray-300">
                        <li class="flex items-center"><span class="text-2xl mr-3">ğŸ‘†</span> <span>ä¸Šæ–¹ç•«é¢ï¼š<b>å·¦å³æ»‘å‹•</b>æ§åˆ¶æˆ°è»Š</span></li>
                        <li class="flex items-center"><span class="text-2xl mr-3">ğŸ‘‡</span> <span>ä¸‹æ–¹æŒ‰éˆ•ï¼š<b>é»æ“Šå–®å­—</b>ç™¼å°„å­å½ˆ</span></li>
                        <li class="flex items-center"><span class="text-2xl mr-3">ğŸ–¼ï¸</span> <span>å°‡åœ–ç‰‡èˆ‡æ­¤æª”æ¡ˆæ”¾åœ¨ä¸€èµ·å³å¯é¡¯ç¤ºåœ–ç‰‡ï¼Œå¦å‰‡é¡¯ç¤ºåœ–ç¤ºã€‚</span></li>
                    </ul>
                </div>
                <button id="startBtn" class="w-full max-w-xs py-4 bg-blue-600 hover:bg-blue-500 rounded-xl text-xl font-bold shadow-lg shadow-blue-500/30 active:scale-95 transition-all">é–‹å§‹éŠæˆ²</button>
            </div>

            <!-- éŠæˆ²çµæŸç•«é¢ -->
            <div id="gameOverScreen" class="hidden absolute inset-0 bg-red-900/95 flex flex-col justify-center items-center z-30 p-6">
                <h2 class="text-4xl font-bold mb-2 text-white">éŠæˆ²çµæŸ</h2>
                <p class="text-lg mb-8 text-red-200">å·®ä¸€é»é»ï¼å†è©¦ä¸€æ¬¡ï¼</p>
                <div class="text-center mb-8">
                    <p class="text-sm text-gray-300 uppercase tracking-widest">æœ€çµ‚åˆ†æ•¸</p>
                    <p class="text-5xl font-mono text-yellow-300 font-bold" id="finalScore">0</p>
                </div>
                <button id="restartBtn" class="px-10 py-3 bg-white text-red-900 rounded-full text-lg font-bold shadow-lg active:scale-95 transition">å†ç©ä¸€æ¬¡</button>
            </div>

            <!-- ç²å‹ç•«é¢ -->
            <div id="winScreen" class="hidden absolute inset-0 bg-yellow-600/95 flex flex-col justify-center items-center z-30 p-6">
                <h2 class="text-4xl font-bold mb-4 text-white">ğŸ‰ é—–é—œæˆåŠŸï¼</h2>
                <p class="text-lg mb-8 text-yellow-100 text-center">æ‰€æœ‰å–®å­—éƒ½å­¸æœƒäº†ï¼</p>
                <div class="text-center mb-8">
                    <p class="text-sm text-yellow-100 uppercase tracking-widest">æœ€çµ‚åˆ†æ•¸</p>
                    <p class="text-5xl font-mono text-white font-bold" id="winScore">0</p>
                </div>
                <button id="winRestartBtn" class="px-10 py-3 bg-white text-yellow-700 rounded-full text-lg font-bold shadow-lg active:scale-95 transition">å†æ¬¡æŒ‘æˆ°</button>
            </div>
        </div>

        <!-- 3. å–®å­—æ§åˆ¶é¢æ¿ (å›ºå®šé«˜åº¦ä½”æ¯” 30%) -->
        <!-- pb-safe: é ç•™ iOS åº•éƒ¨å®‰å…¨è·é›¢ -->
        <div class="h-[30dvh] bg-gray-800 border-t border-gray-600 flex flex-col shrink-0 relative z-20 shadow-[0_-4px_10px_rgba(0,0,0,0.5)]">
            <div class="text-center text-xs text-gray-400 py-1 bg-gray-900/80 backdrop-blur">
                é»æ“Šå–®å­—ç™¼å°„ (å¯ä¸Šä¸‹æ²å‹•é¸å–®)
            </div>
            
            <!-- æ²å‹•å€åŸŸ -->
            <div class="flex-grow overflow-y-auto custom-scroll p-2">
                <!-- 
                   Grid è¨­å®šï¼š
                   - grid-cols-3: æ‰‹æ©Ÿä¸€è¡Œ3å€‹
                   - gap-2: é–“è·
                   - pb-32: â˜…é—œéµâ˜… åº•éƒ¨å¢åŠ å¤§é‡å¡«å…… (ç´„ 128px)ï¼Œç¢ºä¿æœ€å¾Œä¸€è¡Œèƒ½æ»‘ä¸Šä¾†ä¸è¢«é®æ“‹
                -->
                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-2 pb-32" id="wordButtons">
                    <!-- Javascript å‹•æ…‹ç”ŸæˆæŒ‰éˆ• -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- éŠæˆ²è³‡æ–™ ---
        // ç¢ºä¿ img æ¬„ä½èˆ‡æ‚¨çš„æª”åå®Œå…¨ä¸€è‡´
        const VOCABULARY = [
            { word: "fast-food restaurant", img: "fast-food restaurant.png", emoji: "ğŸ”", label: "é€Ÿé£Ÿåº—" },
            { word: "food court", img: "food court.png", emoji: "ğŸ¢", label: "ç¾é£Ÿè¡—" },
            { word: "buffet", img: "buffet.png", emoji: "ğŸ½ï¸", label: "è‡ªåŠ©é¤" },
            { word: "cafeteria", img: "cafeteria.png", emoji: "ğŸ«", label: "è‡ªåŠ©é£Ÿå ‚" },
            { word: "cafÃ©", img: "cafe'.png", emoji: "â˜•", label: "å’–å•¡å»³" },
            { word: "pub", img: "pub.png", emoji: "ğŸº", label: "é…’å§" },
            { word: "pizzeria", img: "pizzeria.png", emoji: "ğŸ•", label: "æŠ«è–©åº—" },
            { word: "food truck", img: "food truck.png", emoji: "ğŸšš", label: "é¤è»Š" },
            { word: "steakhouse", img: "steakhouse.png", emoji: "ğŸ¥©", label: "ç‰›æ’é¤¨" },
            { word: "diner", img: "diner.png", emoji: "ğŸ¥", label: "å°é¤é¤¨" },
            { word: "sandwich bar", img: "sandwich bar.png", emoji: "ğŸ¥ª", label: "ä¸‰æ˜æ²»å§" },
            { word: "street vendor", img: "street vendor.png", emoji: "ğŸ¢", label: "è·¯é‚Šæ”¤" }
        ];

        // --- ç³»çµ±è®Šæ•¸ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');
        const scoreEl = document.getElementById('scoreDisplay');
        const livesEl = document.getElementById('livesDisplay');
        const progressEl = document.getElementById('progressDisplay');
        const finalScoreEl = document.getElementById('finalScore');
        const winScoreEl = document.getElementById('winScore');
        const wordGrid = document.getElementById('wordButtons');
        
        let gameState = 'START';
        let score = 0;
        let lives = 3;
        let lastTime = 0;
        let spawnTimer = 0;
        let spawnInterval = 2000;
        let difficultyMultiplier = 1;
        let animationFrameId;
        
        let clearedWords = new Set();

        const tank = { x: 0, y: 0, width: 50, height: 40, color: '#3b82f6', targetX: 0 };
        let enemies = [];
        let bullets = [];
        let particles = [];

        // --- åœ–ç‰‡é è¼‰é‚è¼¯ ---
        VOCABULARY.forEach(item => {
            const img = new Image();
            
            // ä¿®æ­£ï¼šæ‰‹æ©Ÿç€è¦½å™¨å°æª”åä¸­çš„ç©ºç™½æ”¯æ´è¼ƒå·®ï¼Œå¿…é ˆé€²è¡Œ URL ç·¨ç¢¼
            // ä¾‹å¦‚ "fast-food restaurant.png" æœƒè¢«è½‰ç‚º "fast-food%20restaurant.png"
            const rawPath = item.img;
            
            // ç°¡å–®åˆ¤æ–·ï¼šå¦‚æœä¸æ˜¯ data URI æˆ– http é–‹é ­ï¼Œå‡è¨­æ˜¯ç›¸å°è·¯å¾‘ä¸¦é€²è¡Œç·¨ç¢¼
            if (!rawPath.startsWith('data:') && !rawPath.startsWith('http')) {
                // ä½¿ç”¨ encodeURIComponent ç¢ºä¿ç©ºç™½åŠç‰¹æ®Šå­—å…ƒæ­£ç¢ºè½‰æ›
                img.src = encodeURIComponent(rawPath);
            } else {
                img.src = rawPath;
            }
            
            item.loadedImg = null; 
            
            img.onload = () => { 
                item.loadedImg = img; 
                // console.log(`Loaded: ${item.word}`); 
            };
            img.onerror = () => { 
                // æ‰‹æ©Ÿä¸Šé™¤éŒ¯ç”¨ï¼šå¦‚æœè®€å–å¤±æ•—ï¼Œå°å‡ºå˜—è©¦çš„è·¯å¾‘ï¼Œä¸¦ç¢ºä¿ loadedImg ç‚º null (é€™æ¨£æ‰æœƒé¡¯ç¤º Emoji)
                console.warn(`Failed to load: ${img.src} for ${item.word}`);
                item.loadedImg = null; 
            };
        });

        // --- åˆå§‹åŒ– UI ---
        function initUI() {
            wordGrid.innerHTML = '';
            VOCABULARY.forEach(item => {
                const btn = document.createElement('button');
                btn.id = `btn-${item.word.replace(/[^a-zA-Z0-9]/g, '-')}`;
                // å¢åŠ  min-height ç¢ºä¿æŒ‰éˆ•å¤ å¤§
                btn.className = 'btn-press relative group bg-gray-700 active:bg-gray-600 rounded-lg border border-gray-600 p-1 flex flex-col items-center justify-center min-h-[70px] shadow-sm overflow-hidden select-none';
                
                btn.innerHTML = `
                    <div class="text-xs text-yellow-300 font-bold leading-tight w-full break-words px-1">${item.word}</div>
                    <div class="text-[10px] text-gray-300 mt-1 bg-black/20 px-2 rounded-full">${item.label}</div>
                    <div class="absolute top-1 right-1 opacity-20 text-xl pointer-events-none">${item.emoji}</div>
                `;
                
                const handleAction = (e) => {
                    if (e.type === 'touchstart') e.preventDefault(); 
                    if (gameState === 'PLAYING') {
                        fireBullet(item.word);
                        // æŒ‰éˆ•å›é¥‹
                        if (!btn.classList.contains('bg-green-800')) {
                            btn.style.backgroundColor = '#2563eb';
                            setTimeout(() => {
                                if (!btn.classList.contains('bg-green-800')) {
                                    btn.style.backgroundColor = '';
                                }
                            }, 100);
                        }
                    }
                };

                btn.addEventListener('mousedown', handleAction);
                btn.addEventListener('touchstart', handleAction, {passive: false});

                wordGrid.appendChild(btn);
            });
        }

        // --- è¦–çª—èª¿æ•´ ---
        function resize() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            tank.y = canvas.height - 60;
            tank.x = Math.min(Math.max(tank.x, tank.width/2), canvas.width - tank.width/2);
            tank.targetX = tank.x;
            if (gameState !== 'PLAYING') draw();
        }
        window.addEventListener('resize', resize);
        // é‡å°æ‰‹æ©Ÿè½‰å‘å„ªåŒ–
        window.addEventListener('orientationchange', () => setTimeout(resize, 200));

        // --- éŠæˆ²é‚è¼¯ ---
        function startGame() {
            gameState = 'PLAYING';
            score = 0;
            lives = 3;
            spawnInterval = 2500;
            enemies = [];
            bullets = [];
            particles = [];
            clearedWords.clear();
            
            updateScoreUI();
            updateProgressUI();
            
            // é‡ç½®æŒ‰éˆ•
            document.querySelectorAll('#wordButtons button').forEach(btn => {
                btn.className = 'btn-press relative group bg-gray-700 active:bg-gray-600 rounded-lg border border-gray-600 p-1 flex flex-col items-center justify-center min-h-[70px] shadow-sm overflow-hidden select-none';
                btn.style.backgroundColor = '';
            });

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            
            resize();
            lastTime = performance.now();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop(lastTime);
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            finalScoreEl.innerText = score;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function gameWin() {
            gameState = 'WIN';
            winScoreEl.innerText = score;
            document.getElementById('winScreen').classList.remove('hidden');
            createConfetti();
        }

        function fireBullet(word) {
            bullets.push({
                x: tank.x,
                y: tank.y - 20,
                word: word,
                width: 120,
                speed: canvas.height * 0.015,
                active: true
            });
        }

        function spawnEnemy() {
            const uncollected = VOCABULARY.filter(v => !clearedWords.has(v.word));
            const pool = uncollected.length > 0 ? uncollected : VOCABULARY;
            const item = pool[Math.floor(Math.random() * pool.length)];
            
            const size = Math.min(80, canvas.width * 0.18); 
            const x = Math.random() * (canvas.width - size - 20) + size/2 + 10; 
            
            enemies.push({
                x: x,
                y: -size,
                size: size,
                word: item.word,
                emoji: item.emoji,
                img: item.loadedImg, // å‚³éè¼‰å…¥æˆåŠŸçš„åœ–ç‰‡ç‰©ä»¶
                speed: (canvas.height * 0.002) * (1 + score/2000), 
                active: true
            });
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0, color: color, size: Math.random() * 4 + 2
                });
            }
        }

        function createConfetti() {
            for(let i=0; i<30; i++) {
                setTimeout(() => {
                    createExplosion(
                        canvas.width/2 + (Math.random()-0.5) * canvas.width, 
                        canvas.height/2 + (Math.random()-0.5) * canvas.height, 
                        ['#FFD700', '#FFF', '#F00'][Math.floor(Math.random()*3)]
                    );
                }, i * 100);
            }
        }

        function update(dt) {
            if (gameState !== 'PLAYING') {
                particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
                particles = particles.filter(p => p.life > 0);
                return;
            }

            tank.x += (tank.targetX - tank.x) * 0.15;
            if (tank.x < tank.width/2) tank.x = tank.width/2;
            if (tank.x > canvas.width - tank.width/2) tank.x = canvas.width - tank.width/2;

            spawnTimer += dt;
            const currentInterval = Math.max(800, 2500 - score * 5);
            if (spawnTimer > currentInterval) {
                spawnEnemy();
                spawnTimer = 0;
            }

            bullets.forEach(b => {
                b.y -= b.speed;
                if (b.y < -50) b.active = false;
            });

            enemies.forEach(e => {
                e.y += e.speed;
                
                // ç¢°æ’æª¢æ¸¬ï¼šæˆ°è»Š
                const dx = e.x - tank.x;
                const dy = e.y - tank.y;
                if (Math.sqrt(dx*dx + dy*dy) < (e.size/2 + tank.width/2 - 5)) {
                    createExplosion(tank.x, tank.y, '#ef4444');
                    lives--;
                    updateScoreUI();
                    e.active = false;
                    if (navigator.vibrate) navigator.vibrate(200);
                    if (lives <= 0) gameOver();
                }

                // ç¢°æ’æª¢æ¸¬ï¼šå­å½ˆ
                bullets.forEach(b => {
                    if (!b.active) return;
                    if (Math.abs(b.x - e.x) < (e.size/2 + 20) && Math.abs(b.y - e.y) < e.size/2 + 20) {
                        if (b.word === e.word) {
                            score += 10;
                            if (!clearedWords.has(e.word)) {
                                clearedWords.add(e.word);
                                const btnId = `btn-${e.word.replace(/[^a-zA-Z0-9]/g, '-')}`;
                                const btn = document.getElementById(btnId);
                                if(btn) {
                                    btn.classList.remove('bg-gray-700', 'active:bg-gray-600');
                                    btn.classList.add('bg-green-800', 'border-green-600');
                                }
                            }
                            updateScoreUI();
                            updateProgressUI();
                            createExplosion(e.x, e.y, '#fbbf24');
                            e.active = false;
                            b.active = false;
                            if (clearedWords.size >= VOCABULARY.length) gameWin();
                        } else {
                            b.active = false;
                            createExplosion(b.x, b.y, '#fff');
                        }
                    }
                });

                if (e.y > canvas.height + e.size) e.active = false;
            });

            bullets = bullets.filter(b => b.active);
            enemies = enemies.filter(e => e.active);
            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
            particles = particles.filter(p => p.life > 0);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // èƒŒæ™¯ç¶²æ ¼
            ctx.strokeStyle = '#2d3748'; ctx.lineWidth = 1;
            const gridSize = 50;
            for(let i = (canvas.width/2) % gridSize; i < canvas.width; i += gridSize) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
            }
            for(let i = (canvas.height) % gridSize; i < canvas.height; i += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke();
            }

            // æˆ°è»Š
            ctx.save();
            ctx.translate(tank.x, tank.y);
            ctx.fillStyle = tank.color;
            ctx.beginPath();
            ctx.moveTo(-20, 20); ctx.lineTo(20, 20); ctx.lineTo(15, -10); ctx.lineTo(-15, -10);
            ctx.fill();
            ctx.fillStyle = '#60a5fa'; ctx.fillRect(-5, -30, 10, 25);
            ctx.fillStyle = '#1e3a8a'; ctx.fillRect(-26, 8, 10, 16); ctx.fillRect(16, 8, 10, 16);
            ctx.restore();

            // å­å½ˆ
            ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            bullets.forEach(b => {
                ctx.fillStyle = '#fcd34d'; ctx.fillText(b.word, b.x, b.y);
                ctx.fillStyle = '#f59e0b'; ctx.fillRect(b.x - 2, b.y + 12, 4, 10);
            });

            // æ•µäºº
            enemies.forEach(e => {
                ctx.save();
                ctx.translate(e.x, e.y);
                
                // åˆ¤æ–·æ˜¯å¦é¡¯ç¤ºåœ–ç‰‡
                // å¦‚æœ img å±¬æ€§å­˜åœ¨ä¸”æœ‰æ•ˆ (é null)ï¼Œå‰‡ç•«åœ–
                if (e.img) {
                    // ç•«åœ–ç‰‡
                    // å¦‚æœå·²æ”¶é›†ï¼ŒåŠ å€‹é‡‘è‰²å…‰åœˆèƒŒæ™¯
                    if (clearedWords.has(e.word)) {
                         ctx.shadowColor = '#fbbf24'; ctx.shadowBlur = 15;
                    }
                    try {
                        ctx.drawImage(e.img, -e.size/2, -e.size/2, e.size, e.size);
                    } catch (err) {
                        // è¬ä¸€ç•«åœ–å¤±æ•—ï¼Œå³æ™‚å›é€€åˆ°æ–‡å­—
                        ctx.font = `${e.size * 0.6}px Arial`;
                        ctx.fillStyle = '#fff';
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(e.emoji, 0, 0);
                    }
                    ctx.shadowBlur = 0;
                } else {
                    // æ²’åœ–ç‰‡ï¼Œç•«æ–¹å¡Š + Emoji
                    ctx.strokeStyle = clearedWords.has(e.word) ? '#fbbf24' : '#fff';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = '#1f2937';
                    ctx.beginPath(); ctx.roundRect(-e.size/2, -e.size/2, e.size, e.size, 10);
                    ctx.fill(); ctx.stroke();
                    
                    ctx.font = `${e.size * 0.6}px Arial`;
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(e.emoji, 0, 0);
                }
                ctx.restore();
            });

            // ç²’å­
            particles.forEach(p => {
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;
            });
        }

        function gameLoop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            update(dt);
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function updateScoreUI() {
            scoreEl.innerText = score;
            let livesStr = ''; for(let i=0; i<lives; i++) livesStr += 'â¤';
            livesEl.innerText = livesStr;
        }
        function updateProgressUI() {
            progressEl.innerText = `${clearedWords.size}/${VOCABULARY.length}`;
        }

        function handleInput(clientX) {
            if (gameState !== 'PLAYING') return;
            const rect = canvas.getBoundingClientRect();
            tank.targetX = clientX - rect.left;
        }

        canvas.addEventListener('mousemove', e => handleInput(e.clientX));
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length > 0) handleInput(e.touches[0].clientX);
        }, {passive: false});
        canvas.addEventListener('touchstart', e => {
             e.preventDefault();
             if(e.touches.length > 0) handleInput(e.touches[0].clientX);
        }, {passive: false});

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        document.getElementById('winRestartBtn').addEventListener('click', startGame);

        initUI();
        resize();
        ctx.fillStyle = '#1a202c'; ctx.fillRect(0, 0, canvas.width, canvas.height);

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- åŠ å…¥ viewport-fit=cover ä»¥é©é…å…¨è¢å¹•æ‰‹æ©Ÿ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>é¤é£²å–®å­—å¤§å°„æ“Š (Mobile Optimized)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            /* é˜²æ­¢ä¸‹æ‹‰é‡æ–°æ•´ç†èˆ‡æ»¾å‹• */
            overscroll-behavior: none;
            touch-action: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            /* ä½¿ç”¨ dvh è§£æ±ºæ‰‹æ©Ÿç€è¦½å™¨ç¶²å€åˆ—å•é¡Œ */
            height: 100dvh; 
            width: 100vw;
            background-color: #111827;
        }
        
        .game-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            /* padding-bottom ç§»è‡³å…§éƒ¨å…ƒç´ æ§åˆ¶ï¼Œç¢ºä¿èƒŒæ™¯å»¶ä¼¸ */
        }

        .game-canvas {
            background: linear-gradient(to bottom, #1a202c, #2d3748);
            box-shadow: inset 0 0 20px #000;
            touch-action: none;
        }

        /* è‡ªå®šç¾©æ²è»¸ */
        .word-grid::-webkit-scrollbar {
            width: 4px;
        }
        .word-grid::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 4px;
        }

        .btn-press {
            transition: transform 0.05s, background-color 0.1s;
            touch-action: manipulation; /* å„ªåŒ–é»æ“Šåæ‡‰ */
        }
        .btn-press:active {
            transform: scale(0.96);
        }
    </style>
</head>
<body class="text-white select-none overflow-hidden fixed inset-0">

    <div class="game-container">
        <!-- Game Header: å›ºå®šé«˜åº¦ -->
        <div class="flex justify-between items-center px-3 py-2 bg-gray-800 border-b border-gray-700 h-12 sm:h-14 shrink-0 z-10 shadow-md">
            <div class="flex items-center gap-2">
                <span class="text-2xl">ğŸ”</span>
                <h1 class="text-sm sm:text-lg font-bold text-yellow-400 leading-tight">é¤é£²<br>è¡›å£«</h1>
            </div>
            <div class="flex gap-3 sm:gap-6">
                <div class="text-center">
                    <span class="block text-[10px] text-gray-400 uppercase">Progress</span>
                    <div id="progressDisplay" class="text-sm sm:text-xl font-mono font-bold text-blue-400 leading-none">0/12</div>
                </div>
                <div class="text-center">
                    <span class="block text-[10px] text-gray-400 uppercase">Score</span>
                    <div id="scoreDisplay" class="text-sm sm:text-xl font-mono font-bold text-green-400 leading-none">0</div>
                </div>
                <div class="text-center">
                    <span class="block text-[10px] text-gray-400 uppercase">Lives</span>
                    <div id="livesDisplay" class="text-sm sm:text-xl font-mono font-bold text-red-400 leading-none" style="letter-spacing: -2px;">â¤â¤â¤</div>
                </div>
            </div>
        </div>

        <!-- Canvas Area: è‡ªå‹•å¡«æ»¿å‰©é¤˜ç©ºé–“ -->
        <div class="flex-grow relative w-full overflow-hidden bg-gray-900" id="canvasContainer">
            <canvas id="gameCanvas" class="game-canvas block w-full h-full"></canvas>
            
            <!-- Start Screen Overlay -->
            <div id="startScreen" class="absolute inset-0 bg-black/85 flex flex-col justify-center items-center z-20 p-6 backdrop-blur-sm">
                <h2 class="text-3xl sm:text-4xl font-bold mb-4 text-white text-center">é¤é£²å–®å­—å¤§å°„æ“Š</h2>
                <div class="bg-gray-800 p-4 rounded-xl border border-gray-600 mb-6 max-w-sm w-full">
                    <ul class="space-y-3 text-gray-300 text-sm sm:text-base">
                        <li class="flex items-start"><span class="mr-2">ğŸ‘†</span> <span class="text-white font-bold">ä¸Šæ–¹ç•«é¢ï¼š</span>å·¦å³æ»‘å‹•æ§åˆ¶æˆ°è»Š</li>
                        <li class="flex items-start"><span class="mr-2">ğŸ‘‡</span> <span class="text-white font-bold">ä¸‹æ–¹æŒ‰éˆ•ï¼š</span>é»æ“Šå–®å­—ç™¼å°„å­å½ˆ</li>
                        <li class="flex items-start"><span class="mr-2">ğŸ¯</span> <span class="text-yellow-400">ç›®æ¨™ï¼š</span>æ”¶é›†æ»¿ 12 å€‹å–®å­—</li>
                    </ul>
                </div>
                <button id="startBtn" class="w-full max-w-xs py-4 bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 rounded-xl text-xl font-bold shadow-lg shadow-blue-500/30 transform transition active:scale-95">é–‹å§‹éŠæˆ²</button>
            </div>

            <!-- Game Over Overlay -->
            <div id="gameOverScreen" class="hidden absolute inset-0 bg-red-900/95 flex flex-col justify-center items-center z-30 p-6">
                <h2 class="text-4xl sm:text-5xl font-bold mb-2 text-white">éŠæˆ²çµæŸ</h2>
                <p class="text-lg mb-8 text-red-200">å·®ä¸€é»é»å°±æˆåŠŸäº†ï¼</p>
                <div class="bg-black/30 px-6 py-4 rounded-lg mb-8">
                    <p class="text-sm text-gray-300 text-center uppercase tracking-widest">Final Score</p>
                    <p class="text-4xl font-mono text-yellow-300 font-bold text-center" id="finalScore">0</p>
                </div>
                <button id="restartBtn" class="px-8 py-3 bg-white text-red-900 rounded-full text-lg font-bold shadow-lg active:scale-95 transition">å†ç©ä¸€æ¬¡</button>
            </div>

            <!-- Win Screen Overlay -->
            <div id="winScreen" class="hidden absolute inset-0 bg-yellow-600/95 flex flex-col justify-center items-center z-30 p-6">
                <h2 class="text-4xl sm:text-5xl font-bold mb-4 text-white">ğŸ‰ é—–é—œæˆåŠŸï¼</h2>
                <p class="text-lg mb-8 text-yellow-100 text-center">å¤ªå²å®³äº†ï¼<br>ä½ æ˜¯é¤é£²å–®å­—å¤§å¸«ï¼</p>
                <div class="bg-black/20 px-6 py-4 rounded-lg mb-8">
                    <p class="text-sm text-yellow-100 text-center uppercase tracking-widest">Final Score</p>
                    <p class="text-4xl font-mono text-white font-bold text-center" id="winScore">0</p>
                </div>
                <button id="winRestartBtn" class="px-8 py-3 bg-white text-yellow-700 rounded-full text-lg font-bold shadow-lg active:scale-95 transition">å†æŒ‘æˆ°ä¸€æ¬¡</button>
            </div>
        </div>

        <!-- Word Control Panel: ä½¿ç”¨ padding-bottom env(safe-area-inset-bottom) ç¢ºä¿ä¸è¢« Home Bar æ“‹ä½ -->
        <div class="h-[35%] sm:h-[25%] bg-gray-800 border-t border-gray-600 flex flex-col shrink-0 relative z-10 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.3)] pb-[env(safe-area-inset-bottom)]">
            <div class="text-center text-[10px] sm:text-xs text-gray-400 py-1 bg-gray-900/50">é»æ“Šå–®å­—ç™¼å°„å­å½ˆ (å¯ä¸Šä¸‹æ»‘å‹•)</div>
            <div class="flex-grow overflow-y-auto p-2 word-grid">
                <!-- Mobile: 3 columns, Tablet: 4, Desktop: 6 -->
                <!-- å¢åŠ  pb-20 ç¢ºä¿æœ€å¾Œä¸€è¡Œå¯ä»¥è¢«æ²å‹•ä¸Šä¾†ï¼Œä¸è¢«é‚Šç·£åˆ‡æ‰ -->
                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2 h-full pb-20" id="wordButtons">
                    <!-- Buttons generated by JS -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- éŠæˆ²è³‡æ–™ ---
        const VOCABULARY = [
            { word: "fast-food restaurant", img: "fast-food restaurant.png", emoji: "ğŸ”", label: "é€Ÿé£Ÿåº—" },
            { word: "food court", img: "food court.png", emoji: "ğŸ¢", label: "ç¾é£Ÿè¡—" },
            { word: "buffet", img: "buffet.png", emoji: "ğŸ½ï¸", label: "è‡ªåŠ©é¤" },
            { word: "cafeteria", img: "cafeteria.png", emoji: "ğŸ«", label: "è‡ªåŠ©é£Ÿå ‚" },
            { word: "cafÃ©", img: "cafe'.png", emoji: "â˜•", label: "å’–å•¡å»³" },
            { word: "pub", img: "pub.png", emoji: "ğŸº", label: "é…’å§" },
            { word: "pizzeria", img: "pizzeria.png", emoji: "ğŸ•", label: "æŠ«è–©åº—" },
            { word: "food truck", img: "food truck.png", emoji: "ğŸšš", label: "é¤è»Š" },
            { word: "steakhouse", img: "steakhouse.png", emoji: "ğŸ¥©", label: "ç‰›æ’é¤¨" },
            { word: "diner", img: "diner.png", emoji: "ğŸ¥", label: "å°é¤é¤¨" },
            { word: "sandwich bar", img: "sandwich bar.png", emoji: "ğŸ¥ª", label: "ä¸‰æ˜æ²»å§" },
            { word: "street vendor", img: "street vendor.png", emoji: "ğŸ¢", label: "è·¯é‚Šæ”¤" }
        ];

        // --- ç³»çµ±è®Šæ•¸ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');
        const scoreEl = document.getElementById('scoreDisplay');
        const livesEl = document.getElementById('livesDisplay');
        const progressEl = document.getElementById('progressDisplay');
        const finalScoreEl = document.getElementById('finalScore');
        const winScoreEl = document.getElementById('winScore');
        const wordGrid = document.getElementById('wordButtons');
        
        let gameState = 'START';
        let score = 0;
        let lives = 3;
        let lastTime = 0;
        let spawnTimer = 0;
        let spawnInterval = 2000;
        let difficultyMultiplier = 1;
        let animationFrameId;
        
        // è¿½è¹¤å·²æ”¶é›†çš„å–®å­—
        let clearedWords = new Set();

        // --- éŠæˆ²ç‰©ä»¶ ---
        const tank = {
            x: 0,
            y: 0,
            width: 50,
            height: 40,
            color: '#3b82f6',
            targetX: 0
        };

        let enemies = [];
        let bullets = [];
        let particles = [];

        // --- åˆå§‹åŒ– UI ---
        function initUI() {
            wordGrid.innerHTML = '';
            VOCABULARY.forEach(item => {
                const btn = document.createElement('button');
                btn.id = `btn-${item.word.replace(/\s+/g, '-')}`;
                // ä½¿ç”¨ min-h ä¾†ç¢ºä¿æŒ‰éˆ•é«˜åº¦è¶³å¤ æ‰‹æŒ‡é»æ“Š
                btn.className = 'btn-press relative group bg-gray-700 active:bg-gray-600 rounded-lg border border-gray-600 p-1 flex flex-col items-center justify-center min-h-[60px] sm:min-h-[70px] shadow-sm overflow-hidden';
                
                // æŒ‰éˆ•å…§å®¹æ’ç‰ˆå„ªåŒ–
                btn.innerHTML = `
                    <div class="text-xs text-yellow-300 font-bold leading-tight w-full break-words px-1">${item.word}</div>
                    <div class="text-[10px] text-gray-300 mt-1 bg-black/20 px-2 rounded-full">${item.label}</div>
                    <div class="absolute top-1 right-1 opacity-20 text-xl pointer-events-none">${item.emoji}</div>
                `;
                
                // è™•ç†é»æ“Šèˆ‡è§¸æ§
                const handleAction = (e) => {
                    // é˜²æ­¢é‡è¤‡è§¸ç™¼
                    if (e.type === 'touchstart') e.preventDefault(); 
                    fireBullet(item.word);
                    
                    // æŒ‰éˆ•å›é¥‹å‹•ç•«
                    if (!btn.classList.contains('bg-green-800')) {
                        btn.style.backgroundColor = '#2563eb'; // blue-600
                        btn.style.borderColor = '#60a5fa';
                        setTimeout(() => {
                            if (!btn.classList.contains('bg-green-800')) {
                                btn.style.backgroundColor = '';
                                btn.style.borderColor = '';
                            }
                        }, 150);
                    }
                };

                btn.addEventListener('mousedown', handleAction);
                btn.addEventListener('touchstart', handleAction, {passive: false});

                wordGrid.appendChild(btn);
            });
        }

        // --- èª¿æ•´ Canvas å¤§å° ---
        function resize() {
            const rect = container.getBoundingClientRect();
            // è¨­ç½® canvas çš„å…§éƒ¨è§£æåº¦ç­‰æ–¼é¡¯ç¤ºå¤§å°
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // é‡æ–°å®šä½æˆ°è»Š
            tank.y = canvas.height - 60;
            // ç¢ºä¿æˆ°è»Šåœ¨è¢å¹•å…§
            tank.x = Math.min(Math.max(tank.x, tank.width/2), canvas.width - tank.width/2);
            tank.targetX = tank.x;
            
            // å¦‚æœéŠæˆ²æš«åœä¸­ï¼Œé‡ç¹ªä¸€æ¬¡ä»¥å…é»‘å±
            if (gameState !== 'PLAYING') {
                draw();
            }
        }
        
        // ç›£è½è¢å¹•æ—‹è½‰å’Œå¤§å°æ”¹è®Š
        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => {
            setTimeout(resize, 100); // å»¶é²ä¸€ä¸‹ç­‰å¾…ä½ˆå±€ç©©å®š
        });

        // --- éŠæˆ²é‚è¼¯ ---

        function startGame() {
            gameState = 'PLAYING';
            score = 0;
            lives = 3;
            difficultyMultiplier = 1;
            spawnInterval = 2500;
            enemies = [];
            bullets = [];
            particles = [];
            clearedWords.clear();
            
            updateScoreUI();
            updateProgressUI();
            
            // é‡ç½®æŒ‰éˆ•æ¨£å¼
            document.querySelectorAll('#wordButtons button').forEach(btn => {
                btn.className = 'btn-press relative group bg-gray-700 active:bg-gray-600 rounded-lg border border-gray-600 p-1 flex flex-col items-center justify-center min-h-[60px] sm:min-h-[70px] shadow-sm overflow-hidden';
                btn.style.backgroundColor = '';
                btn.style.borderColor = '';
            });

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            
            resize(); // ç¢ºä¿é–‹å§‹æ™‚å°ºå¯¸æ­£ç¢º
            lastTime = performance.now();
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop(lastTime);
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            finalScoreEl.innerText = score;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function gameWin() {
            gameState = 'WIN';
            winScoreEl.innerText = score;
            document.getElementById('winScreen').classList.remove('hidden');
            createConfetti();
        }

        function fireBullet(word) {
            if (gameState !== 'PLAYING') return;
            bullets.push({
                x: tank.x,
                y: tank.y - 20,
                word: word,
                width: 120,
                speed: canvas.height * 0.015, // é€Ÿåº¦éš¨è¢å¹•é«˜åº¦èª¿æ•´
                active: true
            });
        }

        function spawnEnemy() {
            const uncollected = VOCABULARY.filter(v => !clearedWords.has(v.word));
            const pool = uncollected.length > 0 ? uncollected : VOCABULARY;
            const item = pool[Math.floor(Math.random() * pool.length)];
            
            // æ ¹æ“šè¢å¹•å¯¬åº¦èª¿æ•´æ•µäººå¤§å°
            const size = Math.min(80, canvas.width * 0.18); 
            const x = Math.random() * (canvas.width - size - 20) + size/2 + 10; 
            
            enemies.push({
                x: x,
                y: -size,
                size: size,
                word: item.word,
                emoji: item.emoji,
                speed: (canvas.height * 0.002) * difficultyMultiplier, // é€Ÿåº¦éš¨è¢å¹•é«˜åº¦èª¿æ•´
                active: true,
                maxHealth: 1
            });
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 12; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        function createConfetti() {
            for(let i=0; i<30; i++) {
                setTimeout(() => {
                    createExplosion(
                        canvas.width/2 + (Math.random()-0.5) * canvas.width * 0.8, 
                        canvas.height/2 + (Math.random()-0.5) * canvas.height * 0.5, 
                        ['#FFD700', '#FFF', '#F00', '#0F0', '#00F'][Math.floor(Math.random()*5)]
                    );
                }, i * 100);
            }
        }

        function update(dt) {
            if (gameState !== 'PLAYING') {
                // ç¹¼çºŒæ’­æ”¾ç²’å­å‹•ç•«
                particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
                particles = particles.filter(p => p.life > 0);
                return;
            }

            // é›£åº¦æ¼¸å¢
            difficultyMultiplier = 1 + (score / 1500); 
            const currentSpawnInterval = Math.max(800, 2500 - (score * 8));

            // å¹³æ»‘ç§»å‹•æˆ°è»Š
            tank.x += (tank.targetX - tank.x) * 0.15;
            
            // é‚Šç•Œæª¢æŸ¥
            if (tank.x < tank.width/2) tank.x = tank.width/2;
            if (tank.x > canvas.width - tank.width/2) tank.x = canvas.width - tank.width/2;

            spawnTimer += dt;
            if (spawnTimer > currentSpawnInterval) {
                spawnEnemy();
                spawnTimer = 0;
            }

            // æ›´æ–°å­å½ˆ
            bullets.forEach(b => {
                b.y -= b.speed;
                if (b.y < -50) b.active = false;
            });

            // æ›´æ–°æ•µäººèˆ‡ç¢°æ’
            enemies.forEach(e => {
                e.y += e.speed;

                // æ’æ“Šæˆ°è»Š
                const dx = e.x - tank.x;
                const dy = e.y - tank.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < (e.size/2 + tank.width/2 - 5)) {
                    createExplosion(tank.x, tank.y, '#ef4444');
                    lives--;
                    updateScoreUI();
                    e.active = false;
                    
                    // éœ‡å‹•å›é¥‹ (å¦‚æœè£ç½®æ”¯æ´)
                    if (navigator.vibrate) navigator.vibrate(200);
                    
                    if (lives <= 0) gameOver();
                }

                // å­å½ˆæ“Šä¸­æ•µäºº
                bullets.forEach(b => {
                    if (!b.active) return;
                    
                    // ç°¡å–®çš„çŸ©å½¢ç¢°æ’æª¢æ¸¬
                    if (Math.abs(b.x - e.x) < (e.size/2 + 20) && Math.abs(b.y - e.y) < e.size/2 + 20) {
                        if (b.word === e.word) {
                            // å‘½ä¸­
                            score += 10;
                            if (!clearedWords.has(e.word)) {
                                clearedWords.add(e.word);
                                // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                                const btnId = `btn-${e.word.replace(/\s+/g, '-')}`;
                                const btn = document.getElementById(btnId);
                                if(btn) {
                                    btn.classList.remove('bg-gray-700', 'active:bg-gray-600');
                                    btn.classList.add('bg-green-800', 'border-green-600');
                                }
                            }
                            updateScoreUI();
                            updateProgressUI();
                            createExplosion(e.x, e.y, '#fbbf24');
                            
                            e.active = false;
                            b.active = false;

                            if (clearedWords.size >= VOCABULARY.length) {
                                gameWin();
                            }
                        } else {
                            // æ‰“éŒ¯å–®å­—ï¼Œå­å½ˆæ¶ˆå¤±
                            b.active = false;
                            createExplosion(b.x, b.y - 10, '#fff'); // å°ç«èŠ±
                        }
                    }
                });

                if (e.y > canvas.height + e.size) {
                    e.active = false;
                }
            });

            bullets = bullets.filter(b => b.active);
            enemies = enemies.filter(e => e.active);

            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
            });
            particles = particles.filter(p => p.life > 0);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç¹ªè£½èƒŒæ™¯ç¶²æ ¼
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 1;
            const gridSize = 50;
            // å‚ç›´ç·š
            for(let i = (canvas.width/2) % gridSize; i < canvas.width; i += gridSize) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
            }
            // æ°´å¹³ç·š
            for(let i = (canvas.height) % gridSize; i < canvas.height; i += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke();
            }

            // æˆ°è»Š
            ctx.save();
            ctx.translate(tank.x, tank.y);
            ctx.fillStyle = tank.color;
            // èº«é«”
            ctx.beginPath();
            ctx.moveTo(-20, 20); ctx.lineTo(20, 20); ctx.lineTo(15, -10); ctx.lineTo(-15, -10);
            ctx.fill();
            // ç ²ç®¡
            ctx.fillStyle = '#60a5fa'; ctx.fillRect(-5, -30, 10, 25);
            // å±¥å¸¶
            ctx.fillStyle = '#1e3a8a'; 
            ctx.fillRect(-26, 8, 10, 16); ctx.fillRect(16, 8, 10, 16);
            ctx.restore();

            // å­å½ˆ
            ctx.font = 'bold 16px Arial'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            bullets.forEach(b => {
                ctx.fillStyle = '#fcd34d';
                ctx.fillText(b.word, b.x, b.y);
                ctx.shadowColor = '#f59e0b'; ctx.shadowBlur = 10;
                ctx.fillRect(b.x - 2, b.y + 12, 4, 10); ctx.shadowBlur = 0;
            });

            // æ•µäºº
            enemies.forEach(e => {
                ctx.save();
                ctx.translate(e.x, e.y);
                
                // å¤–æ¡†
                ctx.strokeStyle = clearedWords.has(e.word) ? '#fbbf24' : '#fff';
                ctx.lineWidth = 2;
                
                // èƒŒæ™¯
                ctx.fillStyle = '#1f2937'; // gray-800
                ctx.beginPath();
                ctx.roundRect(-e.size/2, -e.size/2, e.size, e.size, 10);
                ctx.fill();
                ctx.stroke();

                // Emoji
                ctx.font = `${e.size * 0.6}px Arial`;
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(e.emoji, 0, 0);

                ctx.restore();
            });

            // ç²’å­
            particles.forEach(p => {
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });
        }

        function gameLoop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            update(dt);
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function updateScoreUI() {
            scoreEl.innerText = score;
            let livesStr = '';
            for(let i=0; i<lives; i++) livesStr += 'â¤';
            livesEl.innerText = livesStr;
        }

        function updateProgressUI() {
            progressEl.innerText = `${clearedWords.size}/${VOCABULARY.length}`;
        }

        // --- è¼¸å…¥æ§åˆ¶ ---
        function handleInput(clientX) {
            if (gameState !== 'PLAYING') return;
            const rect = canvas.getBoundingClientRect();
            let x = clientX - rect.left;
            tank.targetX = x;
        }

        // æ»‘é¼ æ§åˆ¶
        canvas.addEventListener('mousemove', e => handleInput(e.clientX));
        
        // è§¸æ§æ§åˆ¶ (é‡è¦ï¼šåŠ ä¸Š preventDefault é˜²æ­¢æ»¾å‹•)
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length > 0) {
                handleInput(e.touches[0].clientX);
            }
        }, {passive: false});

        canvas.addEventListener('touchstart', e => {
             e.preventDefault();
             if(e.touches.length > 0) {
                handleInput(e.touches[0].clientX);
             }
        }, {passive: false});

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        document.getElementById('winRestartBtn').addEventListener('click', startGame);

        // --- å•Ÿå‹• ---
        initUI();
        resize(); // åˆå§‹åŒ–å°ºå¯¸
        
        // ç¹ªè£½åˆå§‹ç•«é¢
        ctx.fillStyle = '#1a202c';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç¹ªè£½æ¨™é¡Œå‹•ç•«èƒŒæ™¯ (å¯é¸)
        function idleLoop() {
             if (gameState === 'START') {
                 createExplosion(
                     Math.random() * canvas.width, 
                     Math.random() * canvas.height, 
                     'rgba(255,255,255,0.1)'
                 );
                 update(16);
                 draw();
                 requestAnimationFrame(idleLoop);
             }
        }
        // requestAnimationFrame(idleLoop); // å¦‚æœæƒ³åœ¨é–‹å§‹å‰æœ‰èƒŒæ™¯å‹•ç•«å¯é–‹å•Ÿ

    </script>
</body>
</html>